[[UseCaseDiag]]
= Use Case doc

image::Images\Use_global.PNG[{fullWifth}]

The Use Case diagram describes the main functionalities the project will implement. In a nutshell, this program has three main goals :

* To generate one summarised file containing all the information about the courses and the teachers' preferences. This data exists currently in separate files (one per teacher).
* To help the administration to assign teachers to courses via a GUI.
* After the affectation the program can generate two types of export :
** A global assignment file intended to be used by the administration.
** Multiple assignment files representing the assignment of each teacher.

[[SeqDiag]]
= Sequence diagrams doc

== Global context 

image::Images\Sequence_Global_context.PNG[{fullWifth}]

The idea of this diagram is to present a global view of our project. The program starts by receiving all the files link:Documents\AA_Saisie_des_voeux_2016-2017.ods[“AA-Saisie voeux 2016-2017.ods”] already completed by each teacher. *getDataFromODS()* is the function used to register in a variable of type CalcData the information read in the files “AA-Saisie voeux 2016-2017.ods”. Then, once all the data caught and ordered in variables, the program can generate a file similar to link:Documents\FichierAgrege.pdf[“Fichier Agrégé.pdf”] that summarizes thus all the files “AA-Saisie voeux 2016-2017.ods” loaded.  The function *createSummary()* writes in a Calc to produce a document similar to “Fichier Agrégé.pdf” given in the subject.
Our program, through *writeCoursesInAJsonFile()*, will also generate a json file containing a list of all the courses in the vows files.

If desired by the Admin, our program can end with the generation of the aggregated file. Else, if required by the Admin, our program can continue to help the admin make an assignment. The Assignment process is described in the second sequence diagram (“Sequence_Assignment”), which is refered to in this diagram.

== Assignment

image::Images\Sequence_Assignment.PNG[{fullWifth}]

The idea of this diagram is to present a focus on the assignment process. All the methods used in the messages are meant to evolve later in our project, for now, they simply allow us to describe the principle of our program. We renounced to produce a function that would make the assignment. Instead, we decided to have our interface helping the Admin to assign the teachers. As long as the Admin is not satisfied, the process repeats itself. Once the Admin satisfied, the program will generate the Calc files summarizing the assignments (link:Documents\Fiche_de_service.png[“Fiche de service.ods”] and link:Documents\FichierAgrege.pdf[“Fichier Agrégé.ods”] fully completed). The Admin will receive all these files and will send the “Fiche de service.ods” specific to each teacher. 

[[ClassDiag]]
= Class diagrams doc
== Base classes
image::Images\Class_assignment.PNG[{fullWifth}]

The *CourseAssignment* class represents the assignment of *only one course* to a number of teachers. The *TeacherAssignment* class stores the number of TD, TP, CM groups assigned to one teacher in the selected course. +

*CalcData* represents the data that we can get from the files that the university gives us. The function *getDataFromODS* reads all the necessary informations in the calc link:Documents\AA_Saisie_des_voeux_2016-2017.ods[“AA-Saisie voeux 2016-2017.ods”] to build and return a CalcData.
The classes *Course*, *Teacher* and *CoursePref* are used in that matter.
*CoursePref* represents preferences from a teacher for a specified course.
We'll add getters in the classes as we work on them because it's hard to know exactly what we will need.

== Gui classes
image::Images\Class_Gui.PNG[{fullWifth}]

CoursePrefElement lists in Model are used to represent instances of table items in the GUI.

Here is the process :

Controller initializes the View (*initializeGui* in View) and sets the Model data (*setModelData* in Controller) from ods files thanks to *readFilesFromFolder* in MultipleOdsPrefReader class.

Then the Controller calls the *initPreferences* function in View with the data retrieved from Model. The GUI is now set.

During the initialization of the GUI, listeners for table items are set in View. These listeners call the *callbackListener* from Controller. This method updates the Model (*updatePreferences* in Model), then updates the GUI (*moveTableItem* in View).

A listener is also set for the submit button in View. This listener calls *createAssignments* in Controller. This function retrieves the data from Model to return the assignments for the teachers.

== Ods Reader classes
image::Images\Class_ODS_Read.PNG[{fullWifth}]

The main goal of these classes is to read information from an link:https://github.com/Sarah-Elhelw/teach_spreadsheets/blob/master/Doc/Documents/AA_Saisie_des_voeux_2016-2017.ods[ods file] and create the corresponding CalcData object. The classes Course, Teacher and CoursePref that are created by this process are also returned in order to be used for other purposes (like storing in JSON format the list of courses available in the input file).
*MultipleOdsPrefReader* reads all the ods files present in a certain folder via the *readFilesFromFolder* function.


== Ods Write classes
image::Images\Class_ODS_Write.PNG[{fullWifth}]

We have 2 main writing classes. +

The class *AssignmentPerTeacher* creates a Calc like link:Documents\Fiche_de_service.png[“Fiche_de_service.png”]. The aim of this document is to summarise all the courses a teacher will teach.

The class *OdsSummarizer* creates a Calc like link:Documents\FichierAgrege.pdf[“FichierAgrege.pdf”]. This document shows all the teachers' preferences for a list of courses. Also, if desired, this class can complete the column Assignment in order to show the possible Assignments our program suggest to do.


You can see what the final result will look like in this files :  link:Documents\AssignmentPerTeacher.ods[“AssignmentPerTeacher.ods”] and link:Documents\OdsSummarizer.ods[“OdsSummarizer.ods”]. +

The class *OdsHelper* has some useful functionalities that we use in the two other writing classes.


== Json Read classes
image::Images\Class_Json_Read.png[{fullWifth}]

The main goal of *JsonReader* is to read teachers and courses informations presented in a Json format. These informations are found in RefRof and in files in the class path. RefRof's logins are stored in a file the methods reading RefRof's content need to access.


*InputVowsFile* deals with the files link:Documents\AA_Saisie_des_voeux_2016-2017.ods[“AA-Saisie voeux 2016-2017.ods”]. The method *createPersonalizedFiles* creates personalized calc files, by completing the sheet "Emploi du temps", and puts them in a specified directory.

[[GuiDescription]]
= Gui description

The aim of this gui is to simplify the assignment process by displaying all the theachers' preferences and the courses in one place.In addition, the user can do the assignment via this gui.

image::Images\gui.png[{fullWifth}]

When the user runs this program, he will be met with this interface with all the preferences of all the teachers in the left table (If there's a problem with the reading of the input files an error message will shown instead).The user then can choose to move some of these preferences to the middle table by clicking on the item.The items in the middle table
are considered as selected preferences and represents the preferences that the user accepts. After all the wanted preferences are selected, the user can click on the submit button to generate the
assignment files.

Some notes:

* The table on the right shows all the courses.The user can check it to know the maximum number of each group in each course.
* One item in the left or middle concerns exactly one group.For example, if a teacher wants to teach 2 groups of CM for the course Algèbre then there will be two items (one for each group) in the left table at the start of the program.
* The user can undo a selected preference by clicking on the item in the middle table.
* Some mechanism will later be implemented to signal to the user that he can't select a certain preference if the maximum number of group is already reached. For example if we have a course that accepts only 1 group of TD and there is one item on the middle table concerning 1 TD of that course than the user shouldn't be able to select another group of TD for this course from the left table.
* Another mechanism will later be implemented to signal the user when all the groups have a selected teacher.
