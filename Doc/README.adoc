[[GuiDescription]]
= Gui description :

image::Images\gui.png[width="1054", height="612"]

When the user runs this program, he will be met with this interface with all the preferences of all the teachers in the left table (If there's a problem with the reading of the input files an error message will shown instead).The user then can choose to move some of these preferences to the middle table by clicking on the item.The items in the middle table
are considered as selected preferences and represents the preferences that the user accepts. After all the wanted preferences are selected, the user can click on the submit button to generate the
assignment files.

Some notes:

* The table on the right shows all the courses.The user can check it to know the maximum number of each group in each course.
* The user can undo a selected preference by clicking on the item in the middle table.
* Some mechanism will later be implemented to signal to the user that he can't select a certain preference if the maximum number of group is already reached. For example if we have a course that accepts only 1 group of TD and there is one item on the middle table concerning 1 TD of that course than the user shouldn't be able to select another group of TD for this course from the left table.
* Another mechanism will later be implemented to signal the user when all the groups have a selected teacher.

[[UseCaseDiag]]
= Use Case doc :

image::Images\Use_global.PNG[width="1194", height="621"]

The Use Case diagram describes the main functionalities the project will implement. In a nutshell, this program has three main goals :

* To generate one summarised file containing all the information about the courses and the teachers' preferences. This data exists currently in separate files (one per teacher).
* To help the administration to assign teachers to courses via a GUI.
* After the affectation the program can generate two types of export :
** A global assignment file intended to be used by the administration.
** Multiple assignment files representing the assignment of each teacher.

[[SeqDiag]]
= Sequence diagrams doc :

== Global context 

image::Images\Sequence_Global_context.PNG[width="1285", height="1020]

The idea of this diagram is to present a global view of our project. The program starts by receiving all the files link:Documents\AA_Saisie_des_voeux_2016-2017.ods[“AA-Saisie voeux 2016-2017.ods”] already completed by each teacher. *getData()* is the function used to register in a variable of type CalcData the information read in the files “AA-Saisie voeux 2016-2017.ods”. Then, once all the data caught and ordered in variables, the program can generate a file similar to link:Documents\FichierAgrege.pdf[“Fichier Agrégé.pdf”] that summarizes thus all the files “AA-Saisie voeux 2016-2017.ods” loaded.  The function *createSumarizedOds()* writes in a Calc to produce a document similar to “Fichier Agrégé.pdf” given in the subject. The Admin receives the Calc file created by the function generateAggregatedDataFile(). 

If desired by the Admin, our program can end with the generation of the aggregated file. Else, if required by the Admin, our program can continue to help the admin make an assignment. The Assignment process is described in the second sequence diagram (“Sequence_Assignment”). In order to have a clear and not overloaded diagram, we decided to create a second diagram and put a reference to it in the first one. 

== Assignment

image::Images\Sequence_Assignment.PNG[width="1026", height="1020"]

The idea of this diagram is to present a focus on the assignment process. All the methods used in the messages are meant to evolve later in our project, for now, they simply allow us to describe the principle of our program. We renounced to produce a function that would make the assignment. Instead, we decided to have our interface helping the Admin to assign the teachers (for example, we are thinking of a decrementation of the number of teaching hours for a teacher assigned to a class and displaying it to the Admin). As long as the Admin is not satisfied, the process repeats itself. Once the Admin satisfied, the program will generate the Calc files summarizing the assignments (like link:Documents\services_MIDO.xls[“services MIDO.ods”], link:Documents\Fiche_de_service.png[“Fiche de service.png”] and link:Documents\FichierAgrege.pdf[“Fichier Agrégé.pdf”] fully completed). The Admin will receive all these files and will send the “Fiche de service.png” specific to each teacher. 

[[ClassDiag]]
= Class diagrams doc :
== Base classes :
image::Images\Class_assignment.PNG[width="881", height="1180"]

The *CourseAssignment* class represents the assignment of *only one course* to a number of teachers. The *TeacherAssignment* class stores the number of TD, TP, CM groups assigned to one teacher in the selected course. +

*CalcData* represents the data that we can get from the files that the university gives us. The function *getDataFromODS* reads all the necessary informations in the calc link:Documents\AA_Saisie_des_voeux_2016-2017.ods[“AA-Saisie voeux 2016-2017.ods”] to build and return a CalcData.
The classes *Course*, *Teacher* and *CoursePref* are used in that matter.
*CoursePref* represents preferences from a teacher for a specified course.
We'll add getters in the classes as we work on them because it's hard to know exactly what we will need.

== Gui classes :
image::Images\Class_Gui.PNG[width="979", height="390"]

The View class creates the shell and manages it. 
For the Controller: The function extractPreferenceItems converts the preference information contained in CalcData instances into items that can be inserted in the tables of the gui (left or middle table).
The function createAssignments generates the assignment instances after the the user has validated his choices (by clicking on submit in the gui).

Here is the process : 
At first View sends a signal to Model to set its Data (setData operation in Model), then View populates its tables thanks to updatePreferencesTables operation.

Model contains the preferences that are supposed to be shown in the UI : allPreferencesData for the left column and chosenPreferencesData for the column in the middle (see image of the UI at the end of this document). At the start of the program, chosenPreferencesData is empty.

The View implements listeners that call the callbackListener operation from Controller, when a preference has been double clicked to move it from one column to the other.

The Controller :
- sends a signal to Model to update its data according to the preference that has been clicked (updatePreferences operation in Model).
- sends a signal to View to update its tables according to the new data from Model (updatePreferencesTables operation in View).

We have tried our best to follow the MVC architecture.

== Ods Reader classes :
image::Images\Class_ODS_Read.PNG[width="1360", height="801"]

The main goal of these classes is to read information from an link:https://github.com/Sarah-Elhelw/teach_spreadsheets/blob/master/Doc/Documents/AA_Saisie_des_voeux_2016-2017.ods[ods file] and create the corresponding CalcData object. The classes Course, Teacher and CoursePref that are created by this process are also returned in order to be used for other purposes (like storing in JSON format the list of courses available in the input file).
FilesReader reads all the ods files present in a certain folder via the readFilesFromFolder function.After the reading is done and assuming that there was no error, this class can return the Course instances via the getCourses function (not represented in the diagram).


== Ods Write classes :
image::Images\Class_ODS_Write.PNG[width="590", height="170"]

This class has been already implemented in the first java itération. We will add new classes to this diagram very soon. We are thinking about the best solution to create new Calc Documents to summarize the assignment per teacher and the global assignment. You can see what the final result will look like in this files :  link:Documents\AssigmentPerTeacher.ods[“AssigmentPerTeacher.ods”] and link:Documents\TeachersPreferences.ods[“TeachersPreferences.ods”]. +


== Json Read classes:
image::Images\Class_Json_Read.png[width="710", height="450"]

The main goal of *JsonReader* is to read teachers and courses informations presented in a Json format. These informations are found in RefRof and in files in the class path. RefRof's logins are stored in a file the methods reading RefRof's content need to access.


*InputVowsFile* deals with the files link:Documents\AA_Saisie_des_voeux_2016-2017.ods[“AA-Saisie voeux 2016-2017.ods”]. The method *createPersonalizedFiles* creates personalized calc files, by completing the sheet "Emploi du temps", and puts them in a specified directory. The method *getInputVowsFiles* gets all the names of the calc files that were completed by the teachers and put in a specific directory. 

